using gold.**

toSet(C) :=  {x|  x in C}

///====   mini Parser===

function createParser(A):IPushdownAutomaton begin
	Q:= (0‥10)
	
	Σ:= toSet(A)  ∪ {' ', '\n', '(', ')'}
	
	/*
	 * 'v' para el control de vars, 'b' para el control de las variables en una función, 'p' para el control de funciones
	 * '[' para llevar el control de los bloques, 'i' para llevar el control de los if, 'w' para llevar el control de los while 
	 */
	Γ:={'v','b','p','[','i','w'}
	q₀:= 0
	F:= {"blockEnd","pr5)"}
	M:=GPushdownAutomaton(Q,Σ,Γ,q₀,F)
SkipChars := {' ', '\t', '\n'}   // this will only  be used when testing only the parser as the lexer removes  SkipChars
	
// transitions for  walk(identifier,right)

M.delta(0,1,'w').ignore()
M.delta(1,2,'(').ignore()
M.delta(2,3,'i').ignore()
M.delta(3,4,',').ignore()
M.delta(4,5,'r').ignore()
M.delta(5,0,')').ignore()
 
 // transitions for  walk(number)
M.delta(0,1,'w').ignore()
M.delta(1,2,'(').ignore()
M.delta(2,5,'#').ignore()
M.delta(5,0,')').ignore()

// transitions for  turnto(north)
 
M.delta(0,7,'T').ignore()
M.delta(7,8,'(').ignore()
M.delta(8,9,'n').ignore()
M.delta(9,0,')').ignore()


 for each q in Q do
 	for each s in SkipChars do
 	   M.delta(q,q,λ+s).ignore()
 end
 end


return M
end

