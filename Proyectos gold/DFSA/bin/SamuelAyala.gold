using gold.structures.automaton.*
using gold.visualization.automaton.*


procedure main ( args : String [ ] ) begin
c = createCoder()
GAutomataFrame.show(c)
end


function createCoder ( ) : ITransducer begin

estado = (0‥100) ∪ {'2', '3', '5'}


Q := (estado × estado × estado × estado) ∪ {"E", "I", "F"} 
Σ := {'2', '3', '5', '×', 'q', 'r', 'x', '=', '+', '÷', λ}
Out := {"_"} ∪ ('a'‥'z')
q₀ := "I"
F := Q 
M := GDeterministicTransducer( Q , Σ , Out , q₀ , F , δ , g , h )
return M
end


function δ ( q, s ) begin
	
	alfabeto = {'2', '3', '5', '×', 'q', 'x', '=', '+', '÷'}
	N = 0
	Q = 0
	R = 0
	D = ""
	
	if q = "I" and s ∈ alfabeto then return ⟨(N = N + 1),λ, λ⟩
	
	elseif q = 'x' and s ∈ alfabeto then return ⟨(N = N +1),λ, λ⟩
	
	elseif q = 'q' and s ∈ alfabeto then return ⟨N,(Q = Q +1), λ⟩
	
	elseif q = '2' or q = '3' or q = '5' then return ⟨N, Q, λ, D = q⟩
	
	elseif q = 'r' and s = "" then return ⟨N, Q, (R = R + 1), D⟩
	
	elseif q = 'r' and s = 'r' then return ⟨N, Q, (R = R + 1), D⟩
	
	else return "E"	
	
	end
end

function δ (⟨N, Q, R, D⟩, s) begin
	
	w := false
	i = 0
	cont = 0
	r = 0
	estado = (0‥100) 
	Q := (estado × estado × estado × estado) ∪ {"E", "I", "F"} 
	Σ := {'2', '3', '5', '×', 'q', 'r', 'x', '=', '+', '÷', λ}
	Out := {"_"} ∪ ('a'‥'z')
	q₀ := "I"
	F := Q 
	M := GPushdownAutomaton(Q , Σ , Out , q₀ , F)
	
  if Q = λ or D = λ or R = λ then return s
  
  elseif s = 'q' then return s
  
  while i <= N and N != 0 and N != λ do
  	M.delta('x', 'x', 'x' ).push("x")
  	i = i + 1 
  	end
  
  elseif M.delta('x', '÷', '÷').$skip("x") then
  	
  	M.delta().push("÷")
  	
  elseif M.delta('÷', D, D).$skip("÷")  then
  	
  	M.delta().push(Character.toString(D))
  
  elseif M.delta(D, '=', '=').$skip(D) then
  	
  	M.delta().push("=")
  
  elseif N/(Integer.parseInt(String.valueOf(D))) = Q then
  	while  cont <= Q and Q != 0 and Q != λ do
  	M.delta('=', 'q', 'q').push("q")
  	cont = cont + 1
   end 
  
  elseif M.delta("q", '×', '×').$skip("q")  then
  	
  	M.delta().push("×")
  
  elseif M.delta("×", D, D).$skip("×") then
  	
  	M.delta().push(Character.toString(D))
  
  elseif M.delta(D, '+', '+').$skip(D) then
  	
  	M.delta().push("+")
  
  elseif N%(Integer.parseInt(String.valueOf(D))) = R then
  	while r <= R and R != 0 and R != λ do
  		M.delta("+", 'r', 'r').push("r")
  		r = r + 1
  	end
  
  elseif M.delta().$skip("r") and r > 0 then
 
  	while r > 0 do
  	M.delta().pop("r")
  	r = r - 1
  	end 
  	
  	if M.delta().$skip("+") then
  		M.delta().pop("+")
  	
  	elseif M.delta().$skip((Character.toString(D))) then
  		M.delta().pop((Character.toString(D)))
  	
  	elseif M.delta().$skip("×") then
  		M.delta().pop("×")
  	
  	elseif M.delta().$skip("q") then
  		while cont > 0 do
  			M.delta().pop("q")
  			cont = cont - 1
  			end
  			
  	elseif M.delta().$skip("=") then
  		M.delta().pop("=")
  	
  	elseif M.delta().$skip((Character.toString(D))) then
  		M.delta().pop((Character.toString(D)))
  	
  	elseif M.delta().$skip("÷") then
  		M.delta().pop("÷")
  		if i = 0 and M.delta().$skip(λ) then
  			w = true
  		else return w
  		end 
  		
  	elseif i > 0 then
  		while i > 0 do
  			M.delta().pop("x")
  			i = i - 1 
  		end
  		
  	elseif M.delta().$skip(λ) then
  		w = true
  		
  	else return w
  	end
  
  elseif M.delta().$skip((Character.toString(D))) then
  	M.delta().pop((Character.toString(D)))
  	
  	elseif M.delta().$skip("÷") then
  		M.delta().pop("÷")
  		if i = 0 and M.delta().$skip(λ) then
  			w = true
  		else return w
  		end 
  		
  	elseif i > 0 then
  		while i > 0 do
  			M.delta().pop("x")
  			i = i - 1 
  		end
  		
  	elseif M.delta().$skip(λ) then
  		w = true
  
  else return w
  end
  
  return w
  
 end

 function h ( q, s ) begin
 	
	if q = true then return "La_cadena_pertenece_al_lenguaje"
	 
	else return "La_cadena_NO_pertence_al_lenguaje"
	end

end

function h (⟨N, Q, R, D⟩, s) begin
	
	return λ

end

function g ( q ) begin
	return λ
end